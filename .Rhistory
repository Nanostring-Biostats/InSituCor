metric1(cates, alpha = 0.001, global_mean = 2)
metric1(cates, alpha = 0.2, global_mean = -1)
metric1 = function(cates, alpha = 0.2, global_mean = -1) {
# get mean and CI of cates:
tt <- t.test(cates, conf.level = 1 - alpha)
# get sign vs. global average:
direction <- sign(tt$estimate - global_mean)
# get the relevant confidence limit (lower if the mean is above the global mean; upper otherwise)
if (direction == 1) {
metric <- pmax(tt$conf.int[1] - global_mean, 0)
}
if (direction == -1) {
metric <- pmin(tt$conf.int[2] - global_mean, 0)
}
return(metric)
}
metric1(cates, alpha = 0.2, global_mean = -1)
metric1(cates, alpha = 0.2, global_mean = -2)
metric1(cates, alpha = 0.001, global_mean = -2)
metric1(cates, alpha = 0.000001, global_mean = -2)
metric1(cates, alpha = 0.2, global_mean = .1)
metric1(cates, alpha = 0.2, global_mean = -.1)
mean(cates)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("SpatialDecon")
library(SpatialDecon)
head(ioprofiles)
data(SpatialDecon::safeTME)
head(SpatialDecon::safeTME)
cd4 = rowMeans(safeTME[, c("T.CD8.Naive", "T.CD8.Memory")])
cd8 = rowMeans(safeTME[, c("T.CD8.naive", "T.CD8.memory")])
cd4 = rowMeans(safeTME[, c("T.CD4.naive", "T.CD4.memory")])
treg = safeTME[,"Treg"]
plot(1e-2+cd4,1e-2+cd8,col=0,log = "xy")
text(1e-2+cd4,1e-2+cd8,names(cd8))
par(mfrow =c(1,2))
plot(1e-2+cd4,1e-2+cd8,col=0,log = "xy")
text(1e-2+cd4,1e-2+cd8,names(cd8))
plot(1e-2+cd4,1e-2+cd8,col=0)
text(1e-2+cd4,1e-2+cd8,names(cd8))
library(InSituType)
devtools::install_github("https://github.com/Nanostring-Biostats/InSituType")
10
profiles = InSituType::ioprofiles
receptors = intersect(receptors, rownames(profiles))
receptors = c("CCR1", "CCR2B", "CCR3", "CCR4", "CCR5",
"CXCR3")
receptors = intersect(receptors, rownames(profiles))
par(mfrow = c(2,2))
for (gene in receptors) {
barplot(profiles[gene, ], las = 2, ylab = gene)
}
dev.off()
receptors = c("CCR1", "CCR2B", "CCR3", "CCR4", "CCR5",
"CXCR3", "CD244","CD72")
receptors = intersect(receptors, rownames(profiles))
par(mfrow = c(2,2))
for (gene in receptors) {
barplot(profiles[gene, ], las = 2, ylab = gene)
}
res <- stats::dnbinom(x = matrix(1:10,5), size = size, mu = matrix(1:10,5), log = TRUE)
res <- stats::dnbinom(x = matrix(1:10,5), size = 10, mu = matrix(1:10,5), log = TRUE)
res
tt = ttest(1:10)
tt = t.\test(1:10)
tt = t.test(1:10)
tt$estimate
tt$conf.int
tt$conf.int[1]
library(xgboost)
?xgboost
eval("x = 1")
temp = eval("x = 1")
temp
name = "eta"
eval(name = 1)
name = "lambda"
rpois(1, eval(name) = 1)
rpois(1, substitute(name) = 1)
substitute(name)
substitute(eval(name))
quote(1:2)
quote(name)
quote(eval(name))
name
rpois(1, quote(name) = 1)
?rpoit
?rpois
?match.call
rpois(1, match.call(name) = 1)
get(name)
rpois(1, get(name) = 1)
get(name)
eval(get(name))
call
?eval("x = 1")
x
eval(parse("x = 1"))
eval(parse(text = "x = 1"))
x
?xgboost
sessionInfo()
install.packages("densityPeak")
install.packages("densityClust")
library(densityClust)
?densityClust
library(testthat)
library(cellKlatch)
rm(list = ls())
#temp <- readRDS("data/mini CosMx kidney.RDS")
#annot <- temp$annot
#counts <- temp$counts
#celltype <- temp$celltype
#xy <- temp$xy
#rm(temp)
data(cosmx_kidney)
annot <- cosmx_kidney$annot
counts <- cosmx_kidney$counts
celltype <- cosmx_kidney$annot$celltype
xy <- cosmx_kidney$xy
plot(xy)
dc <- densityClust(xy)
str(dc)
dc$peaks
um = umap(counts)
um = uwot::umap(counts)
um = uwot::umap(as.matrix(counts))
plot(um)
dc <- densityClust(um)
dc$peaks
plot(um)
str(dc)
plot(dc)
dc2 =  findClusters(dc, rho=2, delta=2)
dc <- densityClust(um, k = 20)
dc2 =  findClusters(dc, rho=2, delta=2)
str(dc2)
irisDist <- dist(iris[,1:4])
irisClust <- densityClust(irisDist, gaussian=TRUE)
plot(irisClust) # Inspect clustering attributes to define thresholds
irisClust <- findClusters(irisClust, rho=2, delta=2)
plotMDS(irisClust)
split(iris[,5], irisClust$clusters)
dc = densityClust(neighbors)
neighbors <- radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.05, subset=1)
dc = densityClust(neighbors)
dc = densityClust(neighbors, verbose = TRUE)
# Create a test dataset
x <- c(0, 1, 2, 3, 4, 5)
y <- c(0, 1, 2, 3, 4, 5)
subset <- c(1, 1, 1, 2, 2, 2)
# Define the test
test_that("nearestNeighborGraph returns the correct adjacency matrix", {
adj.m <- nearestNeighborGraph(x, y, N = 2, subset = subset)
expect_identical(class(adj.m), "dgCMatrix")
expect_equal(dim(adj.m), c(length(x), length(x)))
})
adj.m <- nearestNeighborGraph(x, y, N = 2, subset = subset)
adj.m
expect_identical(class(adj.m), "dgCMatrix")
class(adj.m)
expect_equal(dim(adj.m), c(length(x), length(x)))
expect_equal(class(adj.m), "dgCMatrix")
class(adj.m)
class(raw)
class(counts)
class(adj.m)[1]
# Define the test
test_that("nearestNeighborGraph returns the correct adjacency matrix", {
adj.m <- nearestNeighborGraph(x, y, N = 2, subset = subset)
expect_equal(class(adj.m)[1], "dgCMatrix")
expect_equal(dim(adj.m), c(length(x), length(x)))
})
# create sample data for testing
set.seed(123)
counts <- matrix(rnbinom(20000, mu=50, size=1), ncol=100, nrow=200)
celltype <- rep(c("A", "B"), each=50)
xy <- matrix(rnorm(200), ncol=2)
# test that the function returns a list
test_that("cellklatch returns a list", {
res <- cellklatch(counts, celltype=celltype, xy=xy)
expect_is(res, "list")
})
is.list(Res)
is.list(res)
res <- cellklatch(counts, celltype=celltype, xy=xy)
res <- cellklatch(counts, celltype=celltype, xy=xy, k=10)
res <- cellklatch(counts, celltype=celltype, xy=xy, k=10, conditionon = celltype)
res <- cellklatch(counts, celltype=celltype, xy=xy, k=10, conditionon = data.frame(celltype = celltype))
plot(xy)
install.packages("alphahull")
p = alphahull::ashape(xy, alpha = 2)
polygon(p)
p
str(p)
polygon(p$edges)
p
polygon(p$x)
p = alphahull::ashape(xy, alpha = 10)
polygon(p$x)
plot(xy)
polygon(p$x)
ashape
plotp
plot(p)
cormat = condcor
library(testthat)
library(cellKlatch)
rm(list = ls())
#temp <- readRDS("data/mini CosMx kidney.RDS")
#annot <- temp$annot
#counts <- temp$counts
#celltype <- temp$celltype
#xy <- temp$xy
#rm(temp)
data(cosmx_kidney)
annot <- cosmx_kidney$annot
counts <- cosmx_kidney$counts
celltype <- cosmx_kidney$annot$celltype
xy <- cosmx_kidney$xy
neighbors <- radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.05, subset=1)
res <- cellklatch(counts = counts,
conditionon = annot[, c("fov", "totalcounts", "celltype")],
celltype = annot$celltype,
neighbors = NULL, xy = xy, k = NULL, radius = 0.05, tissue = annot$fov, # args for neighbor definition
min_module_size = 2, max_module_size = 20, beta = 12,                # args for module definition
deepSplit = 4, mincor = 0.2, gene_weighting_rule = "inverse_sqrt",   # more args for module definition
roundcortozero = 0.1, max_cells = 1e5,                               # args for controlling memory and compute
attribution_subset_size = 1000,                                      # args for cell type attribution scoring
verbose = TRUE)
softthresh <- (0.5 + 0.5 * res$condcor)^12
softthresh
softthresh <- as.matrix(softthresh)
# create a graph from the similarity matrix
g <- graph_from_adjacency_matrix(softthresh, mode = "directed")
# create a graph from the similarity matrix
g <- igraph::graph_from_adjacency_matrix(softthresh, mode = "directed")
# compute the topological overlap matrix
TOM <- as.matrix(overlap_matrix(g))
# compute the topological overlap matrix
TOM <- as.matrix(matrixStats::overlap_matrix(g))
# compute the topological overlap matrix
TOM <- as.matrix(igraph::overlap_matrix(g))
install.packages("matrixStats")
# compute the topological overlap matrix
TOM <- as.matrix(matrixStats::overlap_matrix(g))
WGCNA::TOMdist
WGCNA::TOMsimilarity
tomSimilarityFromAdj_call
WGCNA:::tomSimilarityFromAdj_call
plot(alphahull::ashape(xy, alpha = 1))
plot(alphahull::ashape(xy, alpha = 0.1))
?ashape
?plot.ashape
plot.ashape
alphahull::plot.ashape
alphahull:::plot.ashape
alphahull::ashape(xy, alpha = 0.1)$edges
head(alphahull::ashape(xy, alpha = 0.1)$edges)
plot(alphahull::ashape(xy, alpha = 0.1)$edges[, c("x1", "y1")])
lines(alphahull::ashape(xy, alpha = 0.1)$edges[, c("x1", "y1")])
tmp  = alphahull::ashape(xy, alpha = 0.1)$edges
lines(tmp[tmp$ind1, c("x1", "y1")])
lines(tmp[order(tmp$ind1), c("x1", "y1")])
plot(tmp[order(tmp$ind1), c("x1", "y1")])
plot(tmp[, c("x1", "y1")])
str(tmp)
plot(tmp[order(tmp[, "ind1"]), c("x1", "y1")])
lines(tmp[order(tmp[, "ind1"]), c("x1", "y1")])
lines(tmp[order(tmp[, "ind2"]), c("x1", "y1")])
plot(tmp[order(tmp[, "ind1"]), c("x1", "y1")])
library(grDevices)
# Function to compute the polygon boundary around a set of points
polygon_boundary <- function(points) {
# Check if input is a matrix or data.frame with two columns (x and y coordinates)
if (!is.matrix(points) && !is.data.frame(points)) {
stop("Input must be a matrix or data.frame with two columns (x and y coordinates)")
}
if (ncol(points) != 2) {
stop("Input must have exactly two columns (x and y coordinates)")
}
# Calculate the convex hull
hull_indices <- chull(points)
# Extract the boundary points
boundary_points <- points[hull_indices, ]
# Close the polygon by adding the first point as the last point
boundary_points <- rbind(boundary_points, boundary_points[1, ])
return(boundary_points)
}
# Example usage
points <- matrix(c(1, 3, 3, 1, 2, 4, 3, 3, 1, 1), ncol = 2, byrow = TRUE)
boundary <- polygon_boundary(points)
print(boundary)
plot(points)
lines(bundary)
lines(boundary)
# Load required packages
library(testthat)
library(grDevices)
# Test cases for the polygon_boundary function
test_that("polygon_boundary works correctly", {
# Test with a simple square
points <- matrix(c(0, 0, 1, 0, 1, 1, 0, 1), ncol = 2, byrow = TRUE)
expect_equal(polygon_boundary(points), rbind(points, points[1, ]))
# Test with a more complex shape
points <- matrix(c(1, 3, 3, 1, 2, 4, 3, 3, 1, 1), ncol = 2, byrow = TRUE)
boundary_expected <- rbind(points[c(1, 2, 5, 3), ], points[1, ])
expect_equal(polygon_boundary(points), boundary_expected)
# Test with collinear points
points <- matrix(c(0, 0, 2, 2, 4, 4), ncol = 2, byrow = TRUE)
boundary_expected <- rbind(points[c(1, 3), ], points[1, ])
expect_equal(polygon_boundary(points), boundary_expected)
# Test with a single point
points <- matrix(c(3, 3), ncol = 2, byrow = TRUE)
expect_equal(polygon_boundary(points), rbind(points, points))
# Test with wrong input types
expect_error(polygon_boundary(42), "Input must be a matrix or data.frame with two columns")
expect_error(polygon_boundary(matrix(1:6, ncol = 3)), "Input must have exactly two columns")
})
# Test with a simple square
points <- matrix(c(0, 0, 1, 0, 1, 1, 0, 1), ncol = 2, byrow = TRUE)
expect_equal(polygon_boundary(points), rbind(points, points[1, ]))
# Test with a more complex shape
points <- matrix(c(1, 3, 3, 1, 2, 4, 3, 3, 1, 1), ncol = 2, byrow = TRUE)
boundary_expected <- rbind(points[c(1, 2, 5, 3), ], points[1, ])
expect_equal(polygon_boundary(points), boundary_expected)
# Test with collinear points
points <- matrix(c(0, 0, 2, 2, 4, 4), ncol = 2, byrow = TRUE)
boundary_expected <- rbind(points[c(1, 3), ], points[1, ])
expect_equal(polygon_boundary(points), boundary_expected)
# Test with collinear points
points <- matrix(c(0, 0, 2, 2, 4, 4), ncol = 2, byrow = TRUE)
boundary_expected <- rbind(points[c(1, 3), ], points[1, ])
expect_equal(polygon_boundary(points), boundary_expected)
# Test with a single point
points <- matrix(c(3, 3), ncol = 2, byrow = TRUE)
expect_equal(polygon_boundary(points), rbind(points, points))
# Test with wrong input types
expect_error(polygon_boundary(42), "Input must be a matrix or data.frame with two columns")
expect_error(polygon_boundary(matrix(1:6, ncol = 3)), "Input must have exactly two columns")
data(iris)
umap_proj <- umap(iris[, 1:4])$layout
colnames(umap_proj) <- c("UMAP1", "UMAP2")
library(umap)
library(ggplot2)
library(gridExtra)
data(iris)
umap_proj <- umap(iris[, 1:4])$layout
colnames(umap_proj) <- c("UMAP1", "UMAP2")
iris_umap <- cbind(umap_proj, iris[, 5])
head(iris_umap)
boundaries <- lapply(unique(iris_umap$Species), function(species) {
species_points <- iris_umap[iris_umap$Species == species, 1:2]
boundary_points <- polygon_boundary(species_points)
data.frame(boundary_points, Species = species)
})
iris_umap
?ahull
lines(boundary)
bouinbdary
boundary
polyon(boundary)
polygon(boundary)
polygon(boundary, col = 2)
xy
ahull(xy)
alphahull::ahull(xy)
alphahull::ahull(xy,alpha = 0.5)
temp = alphahull::ahull(xy,alpha = 0.5)
str(temp)
?alphahull::ahull
temp$ashape.obj$edges
head(temp$ashape.obj$edges)
out <- temp$ashape.obj$edges
out <- temp$ashape.obj$edges
polygon(out[, c("x1", "x2")])
lines(out[, c("x1", "x2")])
plot(x,y)
head(temp)
plot(temp$xahull)
head(xy)
x = xy
temp <- alphahull::ahull(x = y, y = y, alpha = alpha)
temp <- alphahull::ahull(x = y, y = y, alpha = 0.05)
alpha = 0.05
y=NULL
temp <- alphahull::ahull(x = x, y = y, alpha = alpha)
str(temp)
out <- temp$ashape.obj$edges
head(out)
plot(xy)
lines(out[, c("x1", "x2")])
lines(out[, c("x1", "y1")])
plot.ashape
alphahull:::plot.ashape
plot(temp$ashape.obj)
head(out)
# place them in order by their polar coords:
center = c(median(range(out$x1)), median(range(out$x2)))
out$x0 = out$x1 - center[1]
out$y0 = out$y1 - center[2]
# place them in order by their polar coords:
center = c(median(range(out[, "x1"])), median(range(out[, "y1"])))
out$x0 = out[, "x1"] - center[1]
nexy = cbind(out[, "x1"] - center[1],
out[, "y1"] - center[2])
# place them in order by their polar coords:
center = c(median(range(out[, "x1"])), median(range(out[, "y1"])))
head(otu)
head(out)
out <- temp$ashape.obj$edges
# place them in order by their polar coords:
center = c(median(range(out[, "x1"])), median(range(out[, "y1"])))
newxy = cbind(out[, "x1"] - center[1],
out[, "y1"] - center[2])
newxy
arctan
atan2
# place them in order by their polar coords:
center = c(median(range(out[, "x1"])), median(range(out[, "y1"])))
newx <- out[, "x1"] - center[1]
newy <- out[, "y1"] - center[2]
theta <- atan2(newy, newx)
newx <- out[, "x1"] - median(range(out[, "x1"]))
newy <- out[, "y1"] - median(range(out[, "y1"]))
theta <- atan2(newy, newx)
theta
plot(xy)
lines(out[order(theta), c("x1", "y1")])
plot(xy)
lines(out[order(theta), c("x1", "y1")])
polygon(out[order(theta), c("x1", "y1")], col = 2)
out[order(theta), c("x1", "y1")]
#' Derive a polygon from transcript locations
#'
#' Input x and y positions; derive an encircling polygon
#' @param x Vector of x positions or 2-column matrix
#' @param y Vector of y positions
#' @param alpha Passed to alphahull::ahull(). Smaller makes for more nuanced polygons.
#' @return A polygon's coordinated (a 2-column matrix)
#' @importFrom alphahull ahull
getPolyFromTranscripts <- function(x, y = NULL, alpha = 0.1) {
# get the points of the alpha hull:
temp <- alphahull::ahull(x = x, y = y, alpha = alpha)
out <- temp$ashape.obj$edges
# place them in order by their polar coords:
center = c(median(range(out[, "x1"])), median(range(out[, "y1"])))
newx <- out[, "x1"] - median(range(out[, "x1"]))
newy <- out[, "y1"] - median(range(out[, "y1"]))
theta <- atan2(newy, newx)
# return a polygon:
return(out[c(order(theta), order(theta)[1]), c("x1", "y1")])
}
plot(xy)
out = getPolyFromTranscripts(xy, alpha = 0.1)
polygon(out, col = scales::alpha("blue", 0.2))
#temp <- readRDS("data/mini CosMx kidney.RDS")
#annot <- temp$annot
#counts <- temp$counts
#celltype <- temp$celltype
#xy <- temp$xy
#rm(temp)
data(cosmx_kidney)
annot <- cosmx_kidney$annot
counts <- cosmx_kidney$counts
celltype <- cosmx_kidney$annot$celltype
xy <- cosmx_kidney$xy
library(SpatialDecon)
florets(x = rnorm(10), y = rnorm(10), b = matrix(runif(40),10))
florets(x = rnorm(10), y = rnorm(10), b = matrix(runif(40),4))
x = rnorm(10)
y= rnorm(10)
florets(x = x, y = y, b = matrix(runif(40),4))
plot(x,y'')
plot(x,y)
florets(x = x, y = y, b = matrix(runif(40),4))
florets
florets(x = x, y = y, b = matrix(runif(40),4), col = 1:4)
florets(x = x, y = y, b = matrix(runif(40),4), col = 1:4, cex = 5)
x = runif(50)
y = runif(50)
b = matrix(runif(50*6), 6)
dim(b)
florets(x = x, y = y, b = matrix(runif(40),4), col = 1:6, cex = 2)
florets(x = x, y = y, b = b, col = 1:6, cex = 2)
library(SpatialDecon)
x = runif(50)
y = runif(50)
b = matrix(runif(50*4), 4)
colors = c("red","orange","blue","cornflowerblue")
dim(b)
florets(x = x, y = y, b = b, col = colors, cex = 2)
?sparc
?plotCorrelationNetwork
setwd("C:/Users/pdanaher/Documents/GitHub/SPARC")
devtools::document()
library(devtools)
install()
rm(list = ls())
library(devtools)
document()
document()
document()
10^-6
log(10^-6)
10^0.5
log10(3)
10^0.9
context4 <- readRDS("//rnd-qml-c1/tsp.smitapdata.0001/01 SMI TAP project/SMI-0016_ShaunJackson_SeattleCH/6.992 custom analysis w controls/processed_data/context4.RDS")
str(context4)
table(context4)
